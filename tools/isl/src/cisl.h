#ifndef _CISL_H_
#define _CISL_H_

#include "islLexer.h"
#include "islParser.h"
#include "irrlicht.h"
#include "cst.h"
#include "cot.h"

namespace CISL {
    enum CISLStatus {
        E_OK,
        E_NO_FILE,
        E_BAD_INPUT,
        E_OUT_OF_MEMORY,
        E_BAD_SYNTAX
    };

    class CISLErrorHandler 
    {
    public:
        virtual int handleError(int line, int code, irr::core::stringc errMessage)
        {
            printf("CISL Error (%d), line: %d, message: %s\n",code, line, errMessage.c_str());
            return 0;
        }
    };

    class CISL 
    {
    protected:
        pANTLR3_UINT8           m_fileName;
        pANTLR3_INPUT_STREAM    m_inputStream;

        pislLexer               m_lexer;
        CST*                    m_st;       // symbol table
        COT*                    m_ot;       // op table

        // The token stream is produced by the ANTLR3 generated lexer. Again it is a structure based
        // API/Object, which you can customise and override methods of as you wish. a Token stream is
        // supplied to the generated parser, and you can write your own token stream and pass this in
        // if you wish.
        //
        pANTLR3_COMMON_TOKEN_STREAM        m_tokenStream;

        // The Lang parser is also generated by ANTLR and accepts a token stream as explained
        // above. The token stream can be any source in fact, so long as it implements the 
        // ANTLR3_TOKEN_SOURCE interface. In this case the parser does not return anything
        // but it can of course specify any kind of return type from the rule you invoke
        // when calling it. This is the ctx (CTX macro) pointer for your parser.
        //
        pislParser                m_parser;

        // The parser produces an AST, which is returned as a member of the return type of
        // the starting rule (any rule can start first of course). This is a generated type
        // based upon the rule we start with.
        //
        islParser_script_return     m_islAST;


        // The tree nodes are managed by a tree adaptor, which doles
        // out the nodes upon request. You can make your own tree types and adaptors
        // and override the built in versions. See runtime source for details and
        // eventually the wiki entry for the C target.
        //
        pANTLR3_COMMON_TREE_NODE_STREAM    m_treeNodes;

    protected:
        virtual void _freeResources();
        void _dumpTree(pANTLR3_BASE_TREE tree);
        int _buildST(pANTLR3_BASE_TREE tree);
        int _interpret(pANTLR3_BASE_TREE tree);
        int _eval(pANTLR3_BASE_TREE tree, struct EvalResult* pr);
        int _getOp(pANTLR3_BASE_TREE tree, irr::u32 idx, struct EvalResult* pr);
        irr::core::stringc _getDottedName(pANTLR3_BASE_TREE tree);
        int _addDEFSym(pANTLR3_BASE_TREE tree, SymbolType type);
        int _doMath(struct EvalResult* result, ANTLR3_UINT32 op, struct EvalResult* op1, struct EvalResult* op2);

    public:
        CISL();
        virtual ~CISL();

        CISLStatus validateScript(const irr::core::stringc fileName, const CISLErrorHandler& errorHandler=CISLErrorHandler());
        CISLStatus processScript(const irr::core::stringc fileName, const CISLErrorHandler& errorHandler=CISLErrorHandler());

        const irr::video::SMaterial* getMaterial(const irr::core::stringc materialName);
        const irr::video::SColor* getColor(const irr::core::stringc colorName);
        float getFloat(const irr::core::stringc varName);
        int getInt(const irr::core::stringc varName);
        const irr::core::stringc getString(const irr::core::stringc varName);
        const void* getList(const irr::core::stringc varName);

    };
}

#endif