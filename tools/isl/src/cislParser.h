//-----------------------------------------------------------------------------
// Copyright (c) 2006-2008 Tubras Software, Ltd
//
// This software is licensed under the zlib/libpng license. See the file
// "docs/license.txt" for detailed information.
//-----------------------------------------------------------------------------
#ifndef _CISLParser_H_
#define _CISLParser_H_

#include "islLexer.h"
#include "islParser.h"
#include "irrlicht.h"
#include "cst.h"

namespace CISL {

    class CISLParser;

    enum CISLParserStatus {
        E_OK,
        E_NO_FILE,
        E_BAD_INPUT,
        E_OUT_OF_MEMORY,
        E_BAD_SYNTAX
    };

    typedef irr::core::array<irr::core::stringc>  ARRAY;

    class CISLParserErrorHandler 
    {
    public:
        virtual int handleError(int line, int code, irr::core::stringc errMessage)
        {
            printf("CISLParser Error (%d), line: %d, message: %s\n",code, line, errMessage.c_str());
            return 0;
        }
    };

    class CISLParser 
    {
        friend struct LexerContext;
    protected:
        SYMMAP                  m_matDefs;
        SYMMAP                  m_cnfDefs;
        SYMMAP                  m_mtxDefs;
        SYMMAP                  m_layDefs;

        ARRAY                   m_incDirs;
        pANTLR3_UINT8           m_fileName;
        pANTLR3_INPUT_STREAM    m_inputStream;
        STACK                   m_nameSpace;

        irr::u32                m_unNamed;

        pislLexer               m_lexer;
        CST*                    m_st;       // symbol table

        // The token stream is produced by the ANTLR3 generated lexer. Again it is a structure based
        // API/Object, which you can customise and override methods of as you wish. a Token stream is
        // supplied to the generated parser, and you can write your own token stream and pass this in
        // if you wish.
        //
        pANTLR3_COMMON_TOKEN_STREAM        m_tokenStream;

        // The Lang parser is also generated by ANTLR and accepts a token stream as explained
        // above. The token stream can be any source in fact, so long as it implements the 
        // ANTLR3_TOKEN_SOURCE interface. In this case the parser does not return anything
        // but it can of course specify any kind of return type from the rule you invoke
        // when calling it. This is the ctx (CTX macro) pointer for your parser.
        //
        pislParser                m_parser;

        // The parser produces an AST, which is returned as a member of the return type of
        // the starting rule (any rule can start first of course). This is a generated type
        // based upon the rule we start with.
        //
        islParser_script_return     m_islAST;


        // The tree nodes are managed by a tree adaptor, which doles
        // out the nodes upon request. You can make your own tree types and adaptors
        // and override the built in versions. See runtime source for details and
        // eventually the wiki entry for the C target.
        //
        pANTLR3_COMMON_TREE_NODE_STREAM    m_treeNodes;

    protected:
        virtual void _freeResources();
        void _dumpTree(pANTLR3_BASE_TREE tree);
        int _buildST(pANTLR3_BASE_TREE tree);
        int _interpret(pANTLR3_BASE_TREE tree);
        irr::core::stringc _getSpaceID(irr::core::stringc id);
        irr::core::stringc _pushSpace(irr::core::stringc name);
        irr::core::stringc _popSpace();

        void _dumpObjects();
        int _createMaterials(irr::video::IVideoDriver* videoDriver);
        int _createMatrices();
        int _createMaterialLayers(irr::video::IVideoDriver* videoDriver);

        void _printMatrices();

        int _eval(pANTLR3_BASE_TREE tree, pANTLR3_BASE_TREE parent, int cidx, struct EvalResult* pr);
        irr::core::stringc _getIParent(pANTLR3_BASE_TREE tree, pANTLR3_BASE_TREE parent, int cidx);
        int _getOp(pANTLR3_BASE_TREE tree, irr::u32 idx, struct EvalResult* pr);
        irr::core::stringc _extractString(char *str);
        irr::core::stringc _getDottedName(pANTLR3_BASE_TREE tree, irr::u32 startidx=0, irr::u32 endidx=0);
        irr::core::stringc _getScope(pANTLR3_BASE_TREE tree, irr::u32 startidx=0, irr::u32 endidx=0);
        int _startDEFSym(pANTLR3_BASE_TREE tree, SymbolType type);
        int _doMath(struct EvalResult* result, ANTLR3_UINT32 op, struct EvalResult* op1, struct EvalResult* op2);
        EvalResult* _getValueResult(CSymbol* sym, irr::core::stringc val);
        int _getIntValue(EvalResult* er, int defval=0);
        irr::core::stringc _getStringValue(EvalResult*er, irr::core::stringc defval="");
        irr::f32 _getFloatValue(EvalResult* er, irr::f32 defval=0);
        bool _getBoolValue(EvalResult* er, bool defval=false);
        irr::core::matrix4& _getMatrixValue(EvalResult* er);
        irr::u32 _getColorValueFromTuple(const TUPLEITEMS& items, irr::u32 idx);

        irr::core::vector3df& _getVectorValue(EvalResult* er);
        irr::core::vector2df& _getVector2dValue(EvalResult* er);

        const irr::video::SColor& _getColorValue(EvalResult* er);
        bool _getMaterialLayerValue(irr::video::IVideoDriver* videoDriver, CSymbol* parent, 
            irr::core::stringc layerid, irr::video::SMaterialLayer& output);

        irr::core::stringc _extractDir(irr::core::stringc filename);
        void* doInclude(char* filename);
        void  appendIncludeDirs(irr::core::stringc dirs, char sep=';');

        CISLParserStatus validateScript(const irr::core::stringc fileName, const CISLParserErrorHandler& errorHandler=CISLParserErrorHandler());

    public:
        CISLParser();
        virtual ~CISLParser();

        CISLParserStatus parseScript(const irr::core::stringc fileName, const CISLParserErrorHandler& errorHandler=CISLParserErrorHandler());

        const irr::video::SMaterial* getMaterial(const irr::video::IVideoDriver* videoDriver, 
            const irr::core::stringc varName);
        const irr::video::SMaterialLayer* getMaterialLayer(const irr::video::IVideoDriver* videoDriver, 
            const irr::core::stringc varName);

        const irr::core::matrix4& getMatrix(const irr::core::stringc varName);
        const irr::video::SColor* getColor(const irr::core::stringc varName);

        float getFloat(const irr::core::stringc varName);
        int getInt(const irr::core::stringc varName);
        const irr::core::stringc getString(const irr::core::stringc varName);
        const void* getList(const irr::core::stringc varName);

    };

    struct LexerContext {
        islLexer    orgContext;
        CISLParser*       pisl;
        void* doInclude(char* filename) 
        {
            return pisl->doInclude(filename);
        }
    };
}

#endif
