#summary Irrlicht/Blender Exporter v0.2
#labels Featured

= Features =
[http://tubras.googlecode.com/svn/trunk/tools/irrb/irrbmodules/irrblend.png]
The Irrlicht/Blender Exporter exports Blender scene and static node data to the native Irrlicht scene (.irr) and mesh (.irrmesh) file formats.

*Implemented Features*
 * Blender Scene data is exported to Irrlicht native scene format (.irr).
 * Blender Mesh data is exported to the Irrlicht native mesh format (.irrmesh).
 * Export Blender Logic Properties as Irrlicht scene !UserData.
 * Export Lamp, Mesh, Camera, and Empty objects.
 * Export Game Engine Materials and corresponding UV data.
 * Export Blender Generated Lightmap/Baked Materials.
 * Export Object Parent/Child relationships and transforms.
 * Specify Textures as two-sided, transparent, and/or using lighting per face.
 * UV Images may optionally be copied to a user specified location and format.
 * Automatic translation between Blender and Irrlicht coordinate systems.
 * Optionally "walk test" your scene immediately after it is exported using Irrlicht.

*Working on for 0.4*
 * animation
 * bug fixes
 * tutorials

*Todo*
 * Tangent & Binormal calculation for EVT_TANGENTS generation
 * Sound nodes
 * Collision
 * Particles
 * Triggers
 * Animation
----
= Contents =
 * [irrb#Installation Installation]
 * [irrb#Before_You_Start Before You Start]
 * [irrb#Starting_The_Exporter Starting The Exporter]
 * [irrb#The_irrb_Interface The irrb Interface]
 * [irrb#Setting_Up_Output_Locations Setting Up Output Locations]
 * [irrb#Texture_Copying Texture Copying]
 * [irrb#Irrlicht_Material_Generation Irrlicht Material Generation]
 * [irrb#Running_The_Exporter Running The Exporter]
 * [irrb#iwalktest_Integration_And_Usage iwalktest Integration And Usage]
 * [irrb#Binary_Mesh_Format Binary Mesh Format (.irrbmesh)]
 * [irrb#Custom_UserData_Properties Custom UserData Properties]
 * [irrb#Cameras_And_Lights Cameras And Lights]
 * [http://code.google.com/p/tubras/wiki/irrbUtilities Optional Utilities (iwalktest & imeshcvt)]
 * [http://code.google.com/p/tubras/wiki/irrbTutorials Tutorials]
 * [irrb#FAQ FAQ]

*Easy as 123 :)* Okay, maybe 1 can be a little tricky...

[http://tubras.googlecode.com/svn/wiki/images/irrbss9.jpg]

----
= Installation =

The latest stable download of *irrb* is accessible from both the "Project" and "Downloads" tabs of this Google Code project. On the "Projects" tab, *irrb* is listed in the "Featured Downloads" section.

The current version is 0.2.  It may be downloaded from here:
   [http://tubras.googlecode.com/files/irrb-0.2.zip irrb-0.2.zip]

The contents of the zip package are:
{{{
 irrb.py
 irrbmodules/iExporter.py
 irrbmodules/iFilename.py
 irrbmodules/iGUI.py
 irrbmodules/iMaterials.py
 irrbmodules/iMesh.py
 irrbmodules/iMeshBuffer.py
 irrbmodules/irrblend.png
 irrbmodules/iScene.py
 irrbmodules/iTGAWriter.py
 irrbmodules/iUtils.py
 irrbmodules/__init__.py
}}}

Unzip the contents of the zip file into either the Blender scripts directory (".blender/scripts") or the user defined scripts directory.  It is important that the "irrbmodules" directory is created as a sub-directory underneath the Blender/User Defined scripts directory.

*Linux* users *should* install *irrb* to your user defined scripts directory.  If you don't have one, create one and set the location in Blenders Preferences (Python:). This directory should also contain the sub-directories: "bpydata/config" in order for *irrb* to successfully save configuration options between Blender sessions.  Failing to do so, will likely result in *irrb's* configuration data not being saved due to permission related problems.

After *irrb* has been installed, either restart Blender or refresh the Scripts menu by selecting "Update Menus" within the Blender scripts menu.

*irrb* should then appear as an option under the Blender Scripts|Export menu:

[http://tubras.googlecode.com/svn/wiki/images/irrbss1.png]

Documentation on installing and configuring "iwalktest" for both Windows and Linux may be found here: *[http://code.google.com/p/tubras/wiki/irrbUtilities irrb Utilities]*
----
= Before You Start = 

* Key Points *

 * Blender Objects map to Irrlicht scene nodes in scene files (.irr).
 * Blender Mesh Data Blocks map to mesh files (.irrmesh).
 * Multiple Blender Objects may link to the same Mesh Data Block. In this case only a single .irrmesh file will be generated and multiple nodes will be written to the scene file.
 * *irrb* only exports materials that have been UV mapped to images set up in the UV/Image Editor. These are sometimes referred to as "Game Engine Materials".
 
* Details *

Before you start using *irrb* you should at the very least have a fundamental understanding of how to use Blender.  

In order to better understand how *irrb* works with Blender, it will help you to look at the relationship between Blenders "Objects" and "!DataBlocks".

You can find a technical explanation here: *[http://www.blender.org/development/architecture/ Blender Architecture]*

In simpler terms, Blender "Objects" (sometimes referred to as Nodes) specify the Position, Rotation, and Scale of the "!DataBlock" that an "Object" links to.  You may also have multiple "Objects" link to the same "!DataBlock".  Let's have a closer look.

|| [http://tubras.googlecode.com/svn/wiki/images/irrbss2.png] ||
|| *Image 1.* - !LilDaisy, !BigDaisy, and Wilbur. ||

If the entire scene pictured above were to be exported, how many mesh files would be created and how many Irrlicht "nodes" would be written to the "Scene.irr" file?


 # If you answered - 3 mesh files and 3 nodes.  Keep reading.
 # If you answered - 2 mesh files and 3 nodes.  Keep reading.
 # If you answered - it's not possible to tell from the image.  You may skip to the next section.

The reason for not knowing what will be exported is that you must individually select both "cow" objects/nodes to find out if they are linked to the same or different mesh !DataBlocks.

|| [http://tubras.googlecode.com/svn/wiki/images/irrbss2_1.png] ||
|| *Image 2.* - object and mesh datablock links.||

Selecting the cow on the far left (right click in object mode) and pressing F9 (edit mode window), we can see that this cow object is named "!LilDaisy" (OB:!LilDaisy) and it is linked to a mesh !DataBlock named "cow" (ME:cow).

Selecting the cow in the middle would display an object named "!BigDaisy" along with a link to a mesh !DataBlock named "cow".

Selecting the pig on the far right would show the pigs object name is "Wilbur" and that it is linked to a mesh !DataBlock named "pig".

Now that we know which Objects are linked to which !DataBlocks, we can answer the question posed above - "How many mesh files will be created and how many nodes will be written to the  Scene.irr file?".  The answer is

 * 3 nodes will be written to the Scene.irr file: "!LilDaisy", "!BigDaisy", and "Wilbur".
 * 2 .irrmesh files will be created: "cow.irrmesh" and "pig.irrmesh".

The reason only a single "cow.irrmesh" is created is that both cow objects are linked to the same mesh !DataBlock.

You may be asking yourself how can both cow objects use the same mesh file?  The cow on the left (!LilDaisy) is smaller and facing a different direction than !BigDaisy. To answer that, let's have a look at the partial contents of the generated Scene.irr file (lamp and camera excluded):

{{{
<?xml version="1.0"?>
<!-- Created 03/10/2008 10:45 by irrb v0.2 - "Irrlicht/Blender Exporter" -->
<irr_scene>
   <node type="mesh">
      <attributes>
         <string name="Name" value="LilDaisy" />
         <int name="Id" value="-1" />
         <vector3d name="Position" value="-0.880993, -0.278409, 0.000000" />
         <vector3d name="Rotation" value="0.000000, -80.097466, 0.000000" />
         <vector3d name="Scale" value="0.519058, 0.519058, 0.519058" />
         <bool name="Visible" value="true" />
         <bool name="AutomaticCulling" value="true" />
         <bool name="DebugDataVisible" value="false" />
         <bool name="IsDebugObject" value="false" />
         <string name="Mesh" value="c:\test\meshes\cow.irrmesh" />
         <bool name="ReadOnlyMaterials" value="false" />
      </attributes>
   </node>


   <node type="mesh">
      <attributes>
         <string name="Name" value="BigDaisy" />
         <int name="Id" value="-1" />
         <vector3d name="Position" value="0.000000, 0.000000, 0.000000" />
         <vector3d name="Rotation" value="0.000000, 0.000000, 0.000000" />
         <vector3d name="Scale" value="1.000000, 1.000000, 1.000000" />
         <bool name="Visible" value="true" />
         <bool name="AutomaticCulling" value="true" />
         <bool name="DebugDataVisible" value="false" />
         <bool name="IsDebugObject" value="false" />
         <string name="Mesh" value="c:\test\meshes\cow.irrmesh" />
         <bool name="ReadOnlyMaterials" value="false" />
      </attributes>
   </node>
   <node type="mesh">
      <attributes>
         <string name="Name" value="Wilbur" />
         <int name="Id" value="-1" />
         <vector3d name="Position" value="0.840124, -0.324030, -0.066227" />
         <vector3d name="Rotation" value="-90.000000, 180.000000, -0.000000" />
         <vector3d name="Scale" value="1.000000, 1.000000, 1.000000" />
         <bool name="Visible" value="true" />
         <bool name="AutomaticCulling" value="true" />
         <bool name="DebugDataVisible" value="false" />
         <bool name="IsDebugObject" value="false" />
         <string name="Mesh" value="c:\test\meshes\pig.irrmesh" />
         <bool name="ReadOnlyMaterials" value="false" />
      </attributes>
   </node>
</irr_scene>
}}}

We can see that both the !LilDaisy and !BigDaisy nodes reference the same mesh by looking at each nodes "Mesh" attribute:

{{{
         <string name="Mesh" value="c:\test\meshes\cow.irrmesh" />
}}}

So how can !LilDaisy be a different size, position, and orientation?  Well, have a look at the "Position", "Rotation", and "Scale" attributes (transform data) for each node in the Scene.irr data.  They are different.  Looking back at Image 2, we can see that Blender's Object "Transform Properties" are exported to the Scene.irr file.  Compare !LilDaisy's properties in Image 2, to those that were created in the Scene.irr file.  They are the same, except that Blender's Y and Z axis information have been rearranged for your convenience.

*irrb* honors Blender's Object <-> !DataBlock relationships. This may cause unexpected results especially when exporting Meshes only.  More on this later.

|| [http://tubras.googlecode.com/svn/wiki/images/bigpicture.png] ||
|| *Image 3.* - The lil' big picture. ||

As stated in the key points, *irrb* only exports images that have been assigned in the UV/Image editor.  From Image 3 you can see that images may be "assigned" from two different sources:

 * Open an existing image.
 * Create a new blank Image.

Once an image has been assigned to a particular UV layer, you may optionally use Blenders powerful render/procedural material system to create new textures via baking.

It is important to understand that render/procedural materials are NOT exported.  They are simply used for creating textures, lightmaps, and/or normal maps.

----

== Starting The Exporter ==

The easiest and quickest way to call up *irrb* is to select it from the menu: File | Exporters | Irrlicht.  Using this method will typically cause the *irrb* interface to overlay the active window possibly hiding your 3D view.

If you repeatedly export and examine your scene using *[http://code.google.com/p/tubras/wiki/irrbUtilities iwalktest]*, you may find it convenient to run the exporter in "split" screen mode:

|| [http://tubras.googlecode.com/svn/wiki/images/irrbss5.png] ||
|| *Image 4.* - Split Screen View. ||

Steps to create a split screen with *irrb* in the right half of the Blender window:

 # Right click the top border of the 3D view window.
 # Select the "Split Area" menu option.
 # Move the divider to the middle of the 3D view and left click to anchor it.
 # Select "Scripts Window" for the window type (lower left corner of the right half of the screen).
 # In the "Scripts" menu, select "Export" and then "Irrlicht".

----

== The irrb Interface ==

First time *irrb* users will see Image 5 with the default options:

|| [http://tubras.googlecode.com/svn/wiki/images/irrbss3.png] ||
|| *Image 5.* - Default Options. ||
For Windows users, the default Mesh Directory is "c:\temp\" and on Linux the default Mesh Directory will be "/tmp/".

*irrb* stores your preferences and directory locations in a configuration file so your favorite options are remembered between Blender sessions.

Let's take a quick look at all of the *irrb* options:

|| [http://tubras.googlecode.com/svn/wiki/images/irrbss4.png] ||
|| *Image 6.* - *irrb* Options. ||

_note that light/dark green buttons are "toggle" buttons._

*Mesh Directory* - This is the directory location that all exported ".irrmesh" files will be saved to.

*Selected Meshes Only* - This toggle button will only export the meshes that are currently selected in the current scene.  When un-selected, all nodes and linked meshes will be exported.

*Binary* - This toggle button will only appear if you have *[http://code.google.com/p/tubras/wiki/irrbUtilities imeshcvt]* installed and properly configured.  When selected, the meshes will be exported using the "*.irrbmesh*" (binary .irrmesh) format.  *[http://code.google.com/p/tubras/wiki/irrbUtilities imeshcvt]* is the program used to convert from .irrmesh to .irrbmesh.  The original .irrmesh files are left intact. For more information on the .irrbmesh format, see the section named "[irrb#Binary_Mesh_Format Binary Mesh Format]".

*Create Scene File* - Toggle button used to control whether or not a ".irr" scene file is generated.  If selected, scene related options will appear.

*Lights* - Toggle button to indicate whether or not to write light objects/nodes to the ".irr" scene file.

*Cameras* - Toggle button to indicate whether or not to write camera objects/nodes to the ".irr" scene file.

*Scene Directory* - This is the directory location that the ".irr" scene file will be saved to.  The name of the scene file is built using the current Blender scene name that is being exported.  For example, if you named your scene "barnyard", the scene file that is created will be named "barnyard.irr".

*Mesh Path* - This is the relative or absolute path to use when creating the Mesh attribute for Mesh nodes in the ".irr" scene file.  More information on how to use this can be found in the "Settup Up Output Locations" section.

*Copy Textures* - Toggle button that indicates whether or not to copy texture images to a specific location. This option is particularly useful when baking procedural textures onto UV mapped images that are packed into your .blend file.  In other words the images don't exist as individual files on disk.  More information on copying textures can be found in the "Texture Copying" section.

*ORG, TGA* - Mutually exclusive toggle buttons used to indicate what format to save copied images in.  "ORG" will maintain the original image type.  "TGA" will convert the image to TGA.

*Texture Directory* - This is the directory location that copied textures will be saved to.

*Texture Path* - This is the relative or absolute path to use when creating the Texture attribute in the associated ".irrmesh" mesh file.

*Walk Test* - Toggle button that will appear if you have *[http://code.google.com/p/tubras/wiki/irrbUtilities iwalktest]* installed on your system. When selected, iwalktest is executed with your exported scene file as parameter.

*Re-Test* - Button that re-runs *iwalktest* with the last scene exported.

*Export* - Makes the magic happen.

*Exit* - Exits the *irrb* export script.

----
== Setting Up Output Locations ==

* Key Points *

 * For meshes you need to tell *irrb* where to physically save .irrmesh files.
 * If you're generating a scene file (.irr), you need to tell *irrb* how to reference the mesh files in the mesh node data located in the scene file.
 * Reference options include "Full Path", "File Name Only", and "Relative Path".
 * These same points apply to Texture images when you enable texture copying.

* Details *

Before you export a Blender scene, you will need to set up the locations of where your output (scene, mesh, and texture files) will be written to.

If you are simply exporting a mesh that will be loaded into your Irrlicht application or imported by *irrEdit*, you only have to concern yourself with the "Mesh Directory" option.  The path entered into the "Mesh Directory" edit field will be the location where all of your ".irrmesh" files are written to.

Note that *irrb* automatically adjusts your path separator dependent on the operating system you are using.

On the other hand, if you are generating a scene file (.irr) that will be loaded by your Irrlicht application or opened and manipulated by *irrEdit*, you will need to do a little planning.

Each Mesh node entry in an exported scene file contains a "Mesh" attribute.  This attribute is used to link in the actual Mesh data (.irrmesh file) that will be associated with the node.

{{{
         <string name="Mesh" value="c:\test\meshes\cow.irrmesh" />
}}}

There are three options that may be used when generating the Mesh value (*irrb* "Mesh Path" Field):

{{{
         <!-- File Name Only -->
         <string name="Mesh" value="cow.irrmesh" />
}}}
*File Name Only* - Set "Mesh Path" equal to "$filename". In order for the Irrlicht scene loader to actually load a mesh using a file name only, the mesh file must either be in the directory the application is executing from or the mesh must be located on a previously defined *[http://irrlicht.sourceforge.net/docu/classirr_1_1io_1_1_i_file_system.html IFileSystem]* path.
{{{
         <!-- Explicit/Full Path -->
         <string name="Mesh" value="/test/meshes/cow.irrmesh" />
}}}
*Explicit/Full Path* - Set "Mesh Path" equal to "$fullpath" or leave it blank. The Irrlicht scene loader will load the mesh using the full path and mesh file name.  Windows users may include a drive letter at the beginning of the path: "c:/test/meshes/" (still use forward slashes).
{{{
         <!-- Relative Path -->
         <string name="Mesh" value="data/mdl/cow.irrmesh" />
}}}
*Relative Path* - Set "Mesh Path" equal to the relative path you wish to use.  This mode operates in a manner similar to the "Filename Only" mode in that the path must be relative to either the directory the application is executing from or relative to a path that has been previously defined by *[http://irrlicht.sourceforge.net/docu/classirr_1_1io_1_1_i_file_system.html IFileSystem]*.


If you decide to copy your textures, these same "output path" rules apply to the "Texture Path" option in the exporter.

*[http://code.google.com/p/tubras/wiki/irrbUtilities iwalktest]* can be very useful for determining why a mesh isn't appearing in a scene and/or why a texture isn't appearing properly.  The first question to ask yourself: "Is the mesh/texture being loaded?".  *iwalktest* will log mesh/texture loading errors to its log file "iwalktest.log" which is located in the same directory as *iwalktest*.  Windows users can also check for load errors in the *iwalktest* console window if it is configured to be displayed (default).

----
== Texture Copying ==

* Key Points *

 * *irrb* allows you to copy textures from their original location to another directory you specify.
 * Texture copying is convenient when images are generated internally by Blender.
 * Texture copying and *conversion* to TGA can be slow depending on the size and amount of textures your scene contains.
 * The best practice is to reference images on disk and also save your procedurally generated textures to files that are accessible to your application.

* Details *

Why copy textures?  Convenience.

 # You may be working with a .blend file which contains "packed" images.
 # You may not want your Irrlicht application to work against your original texture directory.
 # Your scene may use several procedurally generated textures.

*Packed Images* - 

Blender allows you to "pack" texture images.  This means the images are physically stored in the .blend file.  Images that are stored in the .blend file will NOT be accessible to the application that is loading an exported mesh file.

Why pack images then?  As mentioned above - convenience.  Especially if you exchange .blend files with someone else working on a scene/mesh.

Regardless of the image source (externally opened or created within Blender), you can *pack* and *unpack* an image by clicking on the *packing icon*:

|| [http://tubras.googlecode.com/svn/wiki/images/irrbss6.png] ||
|| *Image 7.* - Blender Packing Icon States. ||

 # *Left* icon indicates the current image *is NOT packed*.
 # *Middle* icon indicates the current image *is packed*.
 # *Right* icon indicates the current image *needs to be re-packed*.  Simply click the packing icon to re-pack the image.

Images will only need to be re-packed if the original image was previously *packed* and then the image is later modified via baking or texture painting.

Images that are created by Blender and neither packed or saved, are stored internally in the .blend file as 24 bit TGA images.  It is important to note that if you modify (texture paint or bake) an image created within Blender, the modifications are not saved internally in the .blend file.  In order to save modifications, you must either pack the image or save it to an external file.

If you choose to NOT copy textures then you are responsible for making sure Blender generated images are saved to disk.  If you forget, *irrb* will display an error message and abort the export.

Regardless as to whether or not you copy textures, you still need to properly set up the "Texture Path" *irrb* option.

Each mesh buffer material located in an .irrmesh file contains four "Texture" attributes (Texture1, Texture2, etc.).  These attributes are used to link in the actual image file(s) that will be associated with the material and mesh buffer.

{{{
         <texture name="Texture1" value="/test/images/cowuvmap.tga"/>
}}}

There are three options that may be used when generating the Texture value (*irrb* "Texture Path" Field):

{{{
         <!-- File Name Only -->
         <texture name="Texture1" value="cowuvmap.tga"/>
}}}
*File Name Only* - Set "Texture Path" equal to "$filename". In order for the Irrlicht scene loader to actually load an image using a file name only, the image file must either be in the directory the application is executing from or the image must be located on a previously defined *[http://irrlicht.sourceforge.net/docu/classirr_1_1io_1_1_i_file_system.html IFileSystem]* path.
{{{
         <!-- Explicit/Full Path -->
         <texture name="Texture1" value="/test/images/cowuvmap.tga"/>
}}}
*Explicit/Full Path* - Set "Texture Path" equal to "$fullpath" or leave it blank. The Irrlicht scene loader will load the image using the full path and image file name.  Windows users may include a drive letter at the beginning of the path: "c:/test/images/" (still use forward slashes).
{{{
         <!-- Relative Path -->
         <string name="Mesh" value="data/tex/cowuvmap.tga" />
}}}
*Relative Path* - Set "Texture Path" equal to the relative path you wish to use.  This mode operates in a manner similar to the "Filename Only" mode in that the path must be relative to either the directory the application is executing from or relative to a path that has been previously defined by *[http://irrlicht.sourceforge.net/docu/classirr_1_1io_1_1_i_file_system.html IFileSystem]*.


----
== Irrlicht Material Generation ==

* Key Points *

 * *irrb* generates Irrlicht materials based on a Blender UV Layer name.
 * UV Images map directly to the Irrlicht material "Texture#" attribute.  Top UV image is written to "Texture1", Second UV image is written to "Texture2"...

* Details *

*irrb* generates Irrlicht materials based on Blenders UV layer stack.  All of Irrlichts standard Materials require either one or two images to be assigned to a materials "texture" attributes located in the .irrmesh file:

{{{
    <material bmat="uvmat:untitled:100">
        <enum name="Type" value="solid"/>
        ...
        <texture name="Texture1" value="cowuvmap.tga"/>
        <texture name="Texture2" value="normalmap.tga"/>
        <texture name="Texture3" value=""/>
        <texture name="Texture4" value=""/>
        ....
    </material>
}}}


*irrb* maps the images assigned in Blender's UV layer stack to the Irrlicht Texture# attribute one to one:

|| [http://tubras.googlecode.com/svn/wiki/images/irrbss7.png] ||
|| *Image 8.* - Blender UV Layer Stack. ||

The image assigned to the top layer is written to the Texture1 attribute.  The image assigned to the second layer is written to the Texture2 attribute.

From the example above you can see a material section in the .irrmesh file format allows up to four texture layers to be defined even though the standard Irrlicht materials only require up to two.

So how does *irrb* determine the type of material to generate? (enum name="Type" value="*solid*") 

Easy, you assign one of Blenders UV layer names an Irrlicht material name that matches one of Irrlichts builtin standard material names.  The built-in standard Irrlicht material names may be found in the [http://irrlicht.sourceforge.net/docu/_e_material_types_8h.html "ematerialtypes.h".] file.  The material names are also defined below for your convenience.

Starting with Blender's top layer in the UV layer stack and working its way down, *irrb* looks for a match against Irrlicht's material names.  If it finds a match, the matching material name will be used as the material type value.

If no match is found, *irrb* defaults the material type to "*solid*".

*irrb* is also capable of generating material types that match your custom material renderer which you register with either *addMaterialRenderer()* or *addAndDropMaterialRenderer()*.  To do this, simply prefix your custom material name with a "$".  For example, if have a custom material renderer named "!MyMaterial", you would enter "$!MyMaterial" in one of Blenders UV layer names.  *irrb* will remove the $ and generate:

{{{
    <material bmat="uvmat:untitled:100">
        <enum name="Type" value="MyMaterial"/>
        ...
    </material>
}}}

*irrb* also honors a couple of Blenders "Texture Face" options:

|| [http://tubras.googlecode.com/svn/wiki/images/irrbss8.png] ||
|| *Image 9.* - Blender Texture Face options. ||

The options are only relevant on the "Primary" UV layer.  The "Primary" UV layer is the layer that matches either one of Irrlichts standard material names or a custom ($) name.  In the absence of a match, the first UV layer is considered the "Primary" UV layer.

The "Texture Face" options that are used by *irrb* are "Light" and "Twoside":

 * *Light* - controls whether or not the face receives lighting.
 * *Twoside* - controls whether or not the face is double-sided. In other words the texture is visble on both sides of the face.

While the *Twoside* texture face option controls individual faces, you may select the "Double Sided" mesh option to override all individual face options.  In other words, if "Double Sided" is selected for the mesh, all materials created for the corresponding mesh will be double sided.  If "Double Sided" is un-selected, the face "Twoside" option is used to determine whether or not individually faces are double sided.

=== Irrlicht Standard Material Types ===

*solid* - Standard solid material. Only first texture is used as the diffuse texture.

*solid_2layer* - Solid material with 2 texture layers. The second is blended onto the first using the alpha value of the vertex colors. This material is currently not implemented in OpenGL, but it works with DirectX.

*lightmap* - Material type with standard lightmap technique: There should be 2 textures: The first texture layer is a diffuse map, the second is a light map. Vertex light is ignored.

*lightmap_add* - Material type with standard lightmap technique but lightmap and diffuse texture are not modulated, but added instead.

*lightmap_m2* - Material type with standard lightmap technique: There should be 2 textures: The first texture layer is a diffuse map, the second is a light map. Vertex light is ignored. The texture colors are effectively multiplied by 2 for brightening. 

*lightmap_m4* - Material type with standard lightmap technique: There should be 2 textures: The first texture layer is a diffuse map, the second is a light map. Vertex light is ignored. The texture colors are effectively multiplied by 4 for brightening.

*lightmap_light* - Like *lightmap*, but also supports dynamic lighting.

*lightmap_light_m2* - Like *lightmap_m2*, but also supports dynamic lighting.

*lightmap_light_m4* - Like *lightmap_m4*, but also supports dynamic lighting.

*detail_map* - Detail mapped material. The first texture is diffuse color map, the second is added to this and usually displayed with a bigger scale value so that it adds more detail. The detail map is added to the diffuse map using ADD_SIGNED, so that it is possible to add and substract color from the diffuse map. For example a value of (127,127,127) will not change the appearance of the diffuse map at all. Often used for terrain rendering.

*sphere_map* - Environment reflection Material.  The "sphere relfection map" must be Texture 1.

*reflection_2layer* - A reflecting material with an optional additional non reflecting texture layer. The reflection map should be set as Texture 1.

*trans_add* - A transparent material. Only the first texture is used. The new color is calculated by simply adding the source color and the dest color. This means if for example a billboard using a texture with black background and a red circle on it is drawn with this material, the result is that only the red circle will be drawn a little bit transparent, and everything which was black is 100% transparent and not visible. This material type is useful for particle effects.

*trans_alphach* - Makes the material transparent based on the texture alpha channel. The final color is blended together from the destination color and the texture color, using the alpha channel value as blend factor. Only first texture is used. If you are using this material with small textures, it is a good idea to load the texture in 32 bit mode (video::IVideoDriver::setTextureCreationFlag()). Also, an alpha ref is used, which can be manipulated using SMaterial::!MaterialTypeParam. If set to 0, the alpha ref gets its default value which is 0.5f and which means that pixels with an alpha value >127 will be written, others not. In other, simple words: this value controls how sharp the edges become when going from a transparent to a solid spot on the texture.  Note that *irrb* sets Param1 to 0.000001.

*trans_alphach_ref* - Makes the material transparent based on the texture alpha channel. If the alpha channel value is greater than 127, a pixel is written to the target, otherwise not. This material does not use alpha blending and is a lot faster than *trans_alphach*. It is ideal for drawing stuff like leaves of plants, because the borders are not blurry but sharp. Only first texture is used. If you are using this material with small textures and 3d object, it is a good idea to load the texture in 32 bit mode (video::IVideoDriver::setTextureCreationFlag()).

*trans_vertex_alpha* - Makes the material transparent based on the vertex alpha value.

*trans_reflection_2layer* - A transparent reflecting material with an optional additional non reflecting texture layer. The reflection map should be set as Texture 1. The transparency depends on the alpha value in the vertex colors. A texture which will not reflect can be set als Texture 2. Please note that this material type is currently not 100% implemented in OpenGL. It works in Direct3D.

*normalmap_solid* - A solid normal map renderer. First texture is the color map, the second should be the normal map. Note that you should use this material only when drawing geometry consisting of vertices of type S3DVertexTangents (EVT_TANGENTS). You can convert any mesh into this format using IMeshManipulator::createMeshWithTangents() (See SpecialFX2 Tutorial). This shader runs on vertex shader 1.1 and pixel shader 1.1 capable hardware and falls back on a fixed function lighted material if this hardware is not available. Only two lights are supported by this shader, if there are more, the nearest two are chosen. Currently, this shader is only implemented for the !D3D8 and !D3D9 renderers.

*normalmap_trans_add* - A transparent normal map renderer. First texture is the color map, the second should be the normal map. Note that you should use this material only when drawing geometry consisting of vertices of type S3DVertexTangents (EVT_TANGENTS). You can convert any mesh into this format using IMeshManipulator::createMeshWithTangents() (See SpecialFX2 Tutorial). This shader runs on vertex shader 1.1 and pixel shader 1.1 capable hardware and falls back on a fixed function lighted material if this hardware is not available. Only two lights are supported by this shader, if there are more, the nearest two are chosen. Currently, this shader is only implemented for the !D3D8 and !D3D9 renderers.

*normalmap_trans_vertexalpha* - A transparent (based on the vertex alpha value) normal map renderer. First texture is the color map, the second should be the normal map. Note that you should use this material only when drawing geometry consisting of vertices of type S3DVertexTangents (EVT_TANGENTS). You can convert any mesh into this format using IMeshManipulator::createMeshWithTangents() (See SpecialFX2 Tutorial). This shader runs on vertex shader 1.1 and pixel shader 1.1 capable hardware and falls back on a fixed function lighted material if this hardware is not available. Only two lights are supported by this shader, if there are more, the nearest two are chosen. Currently, this shader is only implemented for the !D3D8 and !D3D9 renderers.

*parallaxmap_solid* - Just like *normalmap_solid*, but uses parallax mapping too, which looks a lot more realistic. This only works when the hardware supports at least vertex shader 1.1 and pixel shader 1.4. First texture is the color map, the second should be the normal map. The normal map texture should contain the height value in the alpha component. The IVideoDriver::makeNormalMapTexture() method writes this value automaticly when creating normal maps from a heightmap when using a 32 bit texture. The height scale of the material (affecting the bumpiness) is being controlled by the SMaterial::!MaterialTypeParam member. If set to zero, the default value (0.02f) will be applied. Otherwise the value set in SMaterial::!MaterialTypeParam is taken. This value depends on with which scale the texture is mapped on the material. Too high or low values of !MaterialTypeParam can result in strange artifacts.

*parallaxmap_trans_add* - A material just like *parallaxmap_solid*, but it is transparent, using EMT_TRANSPARENT_ADD_COLOR as base material.

*parallaxmap_trans_vertexalpha* - A material just like EMT_PARALLAX_MAP_SOLID, but it is transparent, using EMT_TRANSPARENT_VERTEX_ALPHA as base material.

*onetexture_blend* - !BlendFunc = source * sourceFactor + dest * destFactor ( E_BLEND_FUNC ) Using only Textures(0). generic Blender


----

== Running The Exporter ==

Press the "Export" button to initiate the exporting of your scene and mesh files.

While *irrb* is exporting, the main GUI screen is hidden and status information is displayed in it place.  The status line contains information about the current mesh being exported as well image copying stats if that option was chosen.

You may choose to cancel the export at any time by pressing the Escape key.

After the export has completed, the main GUI screen will again be displayed with a summary of the information that was exported:

[http://tubras.googlecode.com/svn/wiki/images/irrbss16.png]

If *irrb* detects potential problems while exporting, it will display a list of warnings after the export completes.  Click the "Back" button to return to the main GUI window.  


----

== iwalktest Integration And Usage ==

*irrb* integrates an optional package named "iwalktest" which allows you to view and walk through your freshly exported scene using the Irrlicht engine.  iwalktest is currently available to execute on both the Windows and Linux platforms.  

Instructions on iwalktest installation and usage may be found here: *[http://code.google.com/p/tubras/wiki/irrbUtilities irrb Utilities]*

The "Walk Test" GUI button will only appear in *irrb*'s GUI if the following conditions are met:

 # The "IWALKTEST" OS environment variable is defined.
 # The *irrb* "Create Scene File" toggle button is selected.

With these conditions met, it's simply a matter of selecting the "Walk Test" toggle button to view your scene immediately after exporting. 

After you export a scene for the first time, a "Re-Test" push button will appear.  Clicking on this button will re-execute iwalktest with the last scene exported.

If you prefer to run a different application other than the Tubras supplied "iwalktest.exe", you may do so by setting the "IWALKTEST" environment variable to point to your own application.

A couple of notes on how *irrb* executes the external application:

 * *irrb* sets the current directory to the directory in which the external application resides before running the application.

 * *irrb* passes the full scene file path and file name to the external application.  If the environment variable contains a "%s", the scene file is substituted in its place.  If the environment variable doesn't contain a "%s", the scene file is appended as a parameter.

----
== Binary Mesh Format ==

* Key Points *
 * .irrbmesh files (binary mesh) load into your application very quickly. 
 * The code to read/write the .irrbmesh format is freely available to you under the same license as Irrlicht.

* Details *

The .irrbmesh binary mesh format is fast loading.  Irrlicht's native .irrmesh format is based on XML and all though it's nice for exchanging mesh information, it's painfully slow to load.  The following screen shot displays the load times for a high-poly raven mesh exported as .irrmesh, .b3d, and .irrbmesh:

[http://tubras.googlecode.com/svn/wiki/images/irrbss10.jpg]

The respective files sizes and times are:
 * raven.irrmesh - 3,477,652 bytes loaded in 13.4 seconds.
 * raven.b3d - 1,035,025 bytes loaded in 90 *milli*-seconds.
 * raven.irrbmesh - 1,897,579 bytes loaded in 7 *milli*-seconds.

The raven mesh contains approximately 46k faces.  This particular test was run several times in sequence in order to allow Windows disk caching to "work itself out".  The main reason the .irrbmesh format performs so well is that it mimics Irrlicht's internal mesh buffer and material formats.  Very little parsing is required.

*Using .irrbmesh In Your Application*

It is relatively easy to enable your application(s) to read and write .irrbmesh files.  Simply save the following files to your applications source directory.

For Loading:
 * [http://code.google.com/p/tubras/source/browse/trunk/include/CIrrBMeshFileLoader.h CIrrbMeshFileLoader.h]
 * [http://code.google.com/p/tubras/source/browse/trunk/src/CIrrBMeshFileLoader.cpp CIrrBMeshFileLoader.cpp]

For Writing:
 * [http://code.google.com/p/tubras/source/browse/trunk/include/CIrrBMeshWriter.h CIrrbMeshWriter.h]
 * [http://code.google.com/p/tubras/source/browse/trunk/src/CIrrBMeshWriter.cpp CIrrBMeshWriter.cpp]

Then add the following code snippet to your application somewhere in your initialization code:

{{{
    // define _IRR_COMPILE_WITH_IRRB_MESH_LOADER_ to compile the loader
    // loader depends on writers header
    #include "CIrrBMeshWriter.h"
    #include "CIrrBMeshLoader.h"

    // code for loading .irrbmesh files
    //
    // ISceneManager* sceneManager - previously initialized.
    // IFileSystem*   fileSystem   - previously initialized.

    CIrrBMeshFileLoader* loader = new CIrrBMeshFileLoader(sceneManager,fileSystem);
    sceneManager->addExternalMeshLoader(loader);
    loader->drop();

}}}

Now you're ready to load .irrbmesh files:

{{{
    IAnimatedMesh* pmesh  = sceneManager->getMesh("mymesh.irrbmesh");
}}}

To write .irrbmesh files:

{{{
    #include "CIrrBMeshWriter.h"
    // code for writing .irrbmesh files
    //
    // IVideoDriver*  videoDriver  - previously initialized.
    // IFileSystem*   fileSystem   - previously initialized.
    // IMesh*               mesh   - previously initialized.

    IMeshWriter* writer = new CIrrBMeshWriter(m_videoDriver,m_fileSystem);
    IWriteFile* file;
    file = fileSystem->createAndWriteFile("test.irrbmesh");
    writer->writeMesh(file,mesh);
}}}

----
== Custom !UserData Properties ==

*Key Points*
 * *irrb* allows you to export custom properties to scene nodes using Blender's "Logic Properties".

*Details*

The native Irrlicht scene file implements user defined properties using the *<!UserData>* tag.  These properties will typically only have meaning to your custom application.  *irrb* exports Blenders "Logic Properties" as !UserData properties.

In Blender, simply hit the F4 key to display logic properties for a selected mesh:

[http://tubras.googlecode.com/svn/wiki/images/irrbss12.png]

From the picture above, three properties have been defined:

 * testFloat - floating point value.
 * Dynamic - boolean value.
 * ColliderType - string value.

With these properties defined, the following scene node will be generated in the "Scene.irr" file:

{{{
   <node type="mesh">
      <attributes>
         <string name="Name" value="Cube" />
         <int name="Id" value="-1" />
         <vector3d name="Position" value="0.000000, 0.000000, 0.000000" />
         <vector3d name="Rotation" value="0.000000, 0.000000, 0.000000" />
         <vector3d name="Scale" value="1.000000, 1.000000, 1.000000" />
         <bool name="Visible" value="true" />
         <enum name="AutomaticCulling" value="frustum_box" />
         <bool name="DebugDataVisible" value="false" />
         <bool name="IsDebugObject" value="false" />
         <bool name="ReadOnlyMaterials" value="false" />
         <string name="Mesh" value="c:\test\meshes\Cube.irrmesh" />
      </attributes>
      <userData>
         <attributes>
            <float name="testFloat" value="1.500000" />
            <bool name="Dynamic" value="true" />
            <string name="ColliderType" value="box" />
         </attributes>
      </userData>
   </node>
}}}


Note that the scene node standard attributes may also be overridden using Blender's logic properties.  For example, to set "!AutomaticCulling" to "frustum_sphere" instead of the default "frustum_box", create a *String* property named "!AutomaticCulling" and set the value to "frustum_sphere".

In order to access !UserData properties in your application, you will need a class that implements the *[http://irrlicht.sourceforge.net/docu/classirr_1_1scene_1_1_i_scene_user_data_serializer.html ISceneUserDataSerializer]* interface overriding the *!OnReadUserData* method:

{{{

void SerializerClass::loadScene(const c8* fileName)
{
    //
    // ISceneManager* sceneManager  (previously initialized)
    //
    // The 2nd parameter to "loadScene" is a pointer a ISceneUserDataSerializer 
    // interface.
    //
    sceneManager->loadScene(fileName,this);
}

//
// this will be invoked for every scene node that contains UserData attributes.
//
void SerializerClass::OnReadUserData(ISceneNode* forSceneNode, 
    io::IAttributes* userData)
{
    bool value=false;

    if(userData->existsAttribute("Dynamic"))
        value = userData->getAttributeAsBool("Dynamic");

    if(value)
    {
        ESCENE_NODE_TYPE type = forSceneNode->getType();
        if(type == ESNT_MESH)
        {
            //
            // do something to make the mesh "dynamic"
            //
        }
    }
}
}}}

Custom scene node properties aren't limited to just meshes.  They may also be defined for lights and cameras.

----

== Cameras And Lights ==

*Key Points*

 * *irrb* allows you to export camera and light node data to scene files.
 * Camera/Light node attributes are based on some of Blenders setting but may be overridden by assigning specific "logic" properties.

*Camera Details* 

A *camera* node in a .irr scene file will appear as follows:

{{{
   <node type="camera">
      <attributes>
         <string name="Name" value="Camera" />
         <int name="Id" value="-1" />
         <vector3d name="Position" value="7.481132, 5.343665, -6.507640" />
         <vector3d name="Rotation" value="26.440704, -46.691944, 0.000000" />
         <vector3d name="Scale" value="1.000000, 1.000000, 1.000000" />
         <bool name="Visible" value="true" />
         <enum name="AutomaticCulling" value="frustum_box" />
         <bool name="DebugDataVisible" value="false" />
         <bool name="IsDebugObject" value="false" />
         <bool name="ReadOnlyMaterials" value="false" />
         <vector3d name="Target" value="0.000000, 0.000000, 0.000000" />
         <vector3d name="UpVector" value="0.000000, 1.000000, 0.000000" />
         <float name="Fovy" value="0.857556" />
         <float name="Aspect" value="1.250000" />
         <float name="ZNear" value="0.10" />
         <float name="ZFar" value="100.00" />
      </attributes>
   </node>
}}}

The camera specific attributes are: Target, !UpVector, Fovy, Aspect, ZNear, and ZFar.  All but the Target and !UpVector may be set using the Camera properties (F9):

[http://tubras.googlecode.com/svn/wiki/images/irrbss14.png]

*Fovy*. Set to (2 `*` atan(16.0 / (Blenders Lens -> Lens value)).  May be overridden with a "float" logic property named "Fovy".

*Aspect*. Set to the constant 1.25.  May be overridden with a "float" logic property named "Aspect".

*ZNear*. Set to Clipping -> Start value.

*ZFar*. Set to Clipping -> End value.

For now, the Target and !UpVector attributes are set to (0,0,0) and (0,1,0) respectively.

== ==

*Light Details*

A *light* node in a .irr scene file will appear as follows:

{{{
   <node type="light">
      <attributes>
         <string name="Name" value="Lamp" />
         <int name="Id" value="-1" />
         <vector3d name="Position" value="4.076245, 5.903862, 1.005454" />
         <vector3d name="Rotation" value="52.738953, -16.936317, 0.000000" />
         <vector3d name="Scale" value="1.000000, 1.000000, 1.000000" />
         <bool name="Visible" value="true" />
         <enum name="AutomaticCulling" value="frustum_box" />
         <bool name="DebugDataVisible" value="false" />
         <bool name="IsDebugObject" value="false" />
         <bool name="ReadOnlyMaterials" value="false" />
         <enum name="LightType" value="Point" />
         <colorf name="AmbientColor" value="0.000000,0.000000, 0.000000, 1.000000" />
         <colorf name="DiffuseColor" value="1.000000, 1.000000, 1.000000 1.000000" />
         <colorf name="SpecularColor" value="1.000000,1.000000, 1.000000, 1.000000" />
         <vector3d name="Attenuation" value="0.000000 0.500000 0.000000" />
         <float name="Radius" value="60.00" />
         <bool name="CastShadows" value="true" />
      </attributes>
   </node>
}}}

The light specific attributes are: !LightType, !DiffuseColor, !SpecularColor, Attenuation, Radius, and !CastShadows.

[http://tubras.googlecode.com/svn/wiki/images/irrbss15.png]

*!LightType*. Based on Blenders lamp type:
 * lamp -> Point
 * area -> Directional
 * spot -> Spot
 * sun -> Directional
 * hemi -> Directional

*!AmbientColor*. Constant (0,0,0).

*!DiffuseColor*. Set to the R,G,B components of the light color.

*!SpecularColor*. Constant (1,1,1).

*Attenuation*. Set to (0.5 / (Blenders Energy Value)).

*Radius*. Set to (2.0 `*` (Blenders Distance Value)).

*!CastShadows*. Constant "True".

----

== Notes ==

 * add iwalktest export to /etc/environment on Ubuntu

 * if permissions problem saving irrbexport.cfg on Linux, create a writeable user defined scripts directory and point Blender's user defined scripts to it ("Python" in preferences). This newly created directory must contain a sub-directory named "bpydata/config".

 * to view *irrb* stdout debug info on Linux, start Blender from a console window: "gnome-terminal/xterm -e blender -w".  "-w" runs Blender in windowed mode.

 * images/copying.  When Blender creates an image internally, it is created as a 24 bit image with an internal type of Targa (tga).  If the image is saved, it is saved as a 24 bit .tga file even if the the file extension is set to some other extension. The bpy "images" data module allows a bit depth to be specified when creating a new image, but the docs say 32 bit is currently unsupported.  Because of this, we still allow images to be copied, but not "converted" to another type. Originally, conversion appeared to work because the "reading" software was smart enough to recognize the image type even though it's extension didn't match the actual data.  Conversion won't happen unless we include an external Pythonic imaging library or Blender allows us to set the internal image type.

 * it is possible to generate an image within Blender and save it without entering a file  extension.  Blender will save the image to a file with an extension that relates to the image type specified during the save.  However, it doesn't set the extension properly on the internal name.  So, 
    * a generated image with a name of "Untitled"
    * Manually saved as a TGA type (to c:\temp), extension isn't manually entered
    * File will be saved as c:\temp\untitled.tga
    * The internal filename will be set to c:\temp\untitled
    * The image "name" will be set to untitled.tga
 irrb attempts to deal with this, but it is better handled by entering the file extension at the time the image is saved.

 * Blender lamp type conversions lamp->point, area->direction, spot->spot, sun->directional, and hemi->directional.

 * Concave quads should be converted to Triangles before exporting. Show example...

----
== FAQ ==

*Q*: I have a question, where do I go?

*A*:  You may post *irrb* related questions in this [http://irrlicht.sourceforge.net/phpBB2/viewtopic.php?t=27073 Irrlicht thread]. Please read the wiki docs before posting a question. 
----
*Q*: Can I export animated meshes?

*A*: *Not Yet*.  The .irrmesh file format currently doesn't support animation.
----
*Q*: Can *irrb* invoke my own application instead of *iwalktest* after exporting?

*A*: *Yes.*  See the section "[irrb#iwalktest_Integration_And_Usage iwalktest Integration And Usage]"
----
*Q*: Where can I report bugs?

*A*: [http://groups.google.com/group/tubras-development/browse_thread/thread/3ad2e7c3bc844ce1 In the irrb Bug thread.]
----
*Q*: Where can I submit a patch?

*A*: [http://groups.google.com/group/tubras-development/browse_thread/thread/e1592a41bf7b17d8 In the irrb Patch thread.]
----